/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */
import { fetchEncodedAccount, fetchEncodedAccounts, type Account, type Address, type Codec, type Decoder, type EncodedAccount, type Encoder, type FetchAccountConfig, type FetchAccountsConfig, type MaybeAccount, type MaybeEncodedAccount, type ReadonlyUint8Array } from '@solana/kit';
import { type SmartAccountTransactionMessage, type SmartAccountTransactionMessageArgs } from '../types';
export declare const BATCH_TRANSACTION_DISCRIMINATOR: Uint8Array<ArrayBuffer>;
export declare function getBatchTransactionDiscriminatorBytes(): ReadonlyUint8Array;
export type BatchTransaction = {
    discriminator: ReadonlyUint8Array;
    /** PDA bump. */
    bump: number;
    /** The rent collector for the batch transaction account. */
    rentCollector: Address;
    /**
     * Derivation bumps for additional signers.
     * Some transactions require multiple signers. Often these additional signers are "ephemeral" keypairs
     * that are generated on the client with a sole purpose of signing the transaction and be discarded immediately after.
     * When wrapping such transactions into Smart Account ones, we replace these "ephemeral" signing keypairs
     * with PDAs derived from the transaction's `transaction_index` and controlled by the Smart Account Program;
     * during execution the program includes the seeds of these PDAs into the `invoke_signed` calls,
     * thus "signing" on behalf of these PDAs.
     */
    ephemeralSignerBumps: ReadonlyUint8Array;
    /** data required for executing the transaction. */
    message: SmartAccountTransactionMessage;
};
export type BatchTransactionArgs = {
    /** PDA bump. */
    bump: number;
    /** The rent collector for the batch transaction account. */
    rentCollector: Address;
    /**
     * Derivation bumps for additional signers.
     * Some transactions require multiple signers. Often these additional signers are "ephemeral" keypairs
     * that are generated on the client with a sole purpose of signing the transaction and be discarded immediately after.
     * When wrapping such transactions into Smart Account ones, we replace these "ephemeral" signing keypairs
     * with PDAs derived from the transaction's `transaction_index` and controlled by the Smart Account Program;
     * during execution the program includes the seeds of these PDAs into the `invoke_signed` calls,
     * thus "signing" on behalf of these PDAs.
     */
    ephemeralSignerBumps: ReadonlyUint8Array;
    /** data required for executing the transaction. */
    message: SmartAccountTransactionMessageArgs;
};
export declare function getBatchTransactionEncoder(): Encoder<BatchTransactionArgs>;
export declare function getBatchTransactionDecoder(): Decoder<BatchTransaction>;
export declare function getBatchTransactionCodec(): Codec<BatchTransactionArgs, BatchTransaction>;
export declare function decodeBatchTransaction<TAddress extends string = string>(encodedAccount: EncodedAccount<TAddress>): Account<BatchTransaction, TAddress>;
export declare function decodeBatchTransaction<TAddress extends string = string>(encodedAccount: MaybeEncodedAccount<TAddress>): MaybeAccount<BatchTransaction, TAddress>;
export declare function fetchBatchTransaction<TAddress extends string = string>(rpc: Parameters<typeof fetchEncodedAccount>[0], address: Address<TAddress>, config?: FetchAccountConfig): Promise<Account<BatchTransaction, TAddress>>;
export declare function fetchMaybeBatchTransaction<TAddress extends string = string>(rpc: Parameters<typeof fetchEncodedAccount>[0], address: Address<TAddress>, config?: FetchAccountConfig): Promise<MaybeAccount<BatchTransaction, TAddress>>;
export declare function fetchAllBatchTransaction(rpc: Parameters<typeof fetchEncodedAccounts>[0], addresses: Array<Address>, config?: FetchAccountsConfig): Promise<Account<BatchTransaction>[]>;
export declare function fetchAllMaybeBatchTransaction(rpc: Parameters<typeof fetchEncodedAccounts>[0], addresses: Array<Address>, config?: FetchAccountsConfig): Promise<MaybeAccount<BatchTransaction>[]>;
