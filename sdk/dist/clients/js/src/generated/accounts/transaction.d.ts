/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */
import { fetchEncodedAccount, fetchEncodedAccounts, type Account, type Address, type Codec, type Decoder, type EncodedAccount, type Encoder, type FetchAccountConfig, type FetchAccountsConfig, type MaybeAccount, type MaybeEncodedAccount, type ReadonlyUint8Array } from '@solana/kit';
import { type SmartAccountTransactionMessage, type SmartAccountTransactionMessageArgs } from '../types';
export declare const TRANSACTION_DISCRIMINATOR: Uint8Array<ArrayBuffer>;
export declare function getTransactionDiscriminatorBytes(): ReadonlyUint8Array;
export type Transaction = {
    discriminator: ReadonlyUint8Array;
    /** The settings this belongs to. */
    settings: Address;
    /** Signer of the Smart Account who submitted the transaction. */
    creator: Address;
    /** The rent collector for the transaction account. */
    rentCollector: Address;
    /** Index of this transaction within the smart account. */
    index: bigint;
    /** bump for the transaction seeds. */
    bump: number;
    /** The account index of the smart account this transaction belongs to. */
    accountIndex: number;
    /** Derivation bump of the smart account PDA this transaction belongs to. */
    accountBump: number;
    /**
     * Derivation bumps for additional signers.
     * Some transactions require multiple signers. Often these additional signers are "ephemeral" keypairs
     * that are generated on the client with a sole purpose of signing the transaction and be discarded immediately after.
     * When wrapping such transactions into smart account ones, we replace these "ephemeral" signing keypairs
     * with PDAs derived from the SmartAccountTransaction's `transaction_index`
     * and controlled by the Smart Account Program;
     * during execution the program includes the seeds of these PDAs into the `invoke_signed` calls,
     * thus "signing" on behalf of these PDAs.
     */
    ephemeralSignerBumps: ReadonlyUint8Array;
    /** data required for executing the transaction. */
    message: SmartAccountTransactionMessage;
};
export type TransactionArgs = {
    /** The settings this belongs to. */
    settings: Address;
    /** Signer of the Smart Account who submitted the transaction. */
    creator: Address;
    /** The rent collector for the transaction account. */
    rentCollector: Address;
    /** Index of this transaction within the smart account. */
    index: number | bigint;
    /** bump for the transaction seeds. */
    bump: number;
    /** The account index of the smart account this transaction belongs to. */
    accountIndex: number;
    /** Derivation bump of the smart account PDA this transaction belongs to. */
    accountBump: number;
    /**
     * Derivation bumps for additional signers.
     * Some transactions require multiple signers. Often these additional signers are "ephemeral" keypairs
     * that are generated on the client with a sole purpose of signing the transaction and be discarded immediately after.
     * When wrapping such transactions into smart account ones, we replace these "ephemeral" signing keypairs
     * with PDAs derived from the SmartAccountTransaction's `transaction_index`
     * and controlled by the Smart Account Program;
     * during execution the program includes the seeds of these PDAs into the `invoke_signed` calls,
     * thus "signing" on behalf of these PDAs.
     */
    ephemeralSignerBumps: ReadonlyUint8Array;
    /** data required for executing the transaction. */
    message: SmartAccountTransactionMessageArgs;
};
export declare function getTransactionEncoder(): Encoder<TransactionArgs>;
export declare function getTransactionDecoder(): Decoder<Transaction>;
export declare function getTransactionCodec(): Codec<TransactionArgs, Transaction>;
export declare function decodeTransaction<TAddress extends string = string>(encodedAccount: EncodedAccount<TAddress>): Account<Transaction, TAddress>;
export declare function decodeTransaction<TAddress extends string = string>(encodedAccount: MaybeEncodedAccount<TAddress>): MaybeAccount<Transaction, TAddress>;
export declare function fetchTransaction<TAddress extends string = string>(rpc: Parameters<typeof fetchEncodedAccount>[0], address: Address<TAddress>, config?: FetchAccountConfig): Promise<Account<Transaction, TAddress>>;
export declare function fetchMaybeTransaction<TAddress extends string = string>(rpc: Parameters<typeof fetchEncodedAccount>[0], address: Address<TAddress>, config?: FetchAccountConfig): Promise<MaybeAccount<Transaction, TAddress>>;
export declare function fetchAllTransaction(rpc: Parameters<typeof fetchEncodedAccounts>[0], addresses: Array<Address>, config?: FetchAccountsConfig): Promise<Account<Transaction>[]>;
export declare function fetchAllMaybeTransaction(rpc: Parameters<typeof fetchEncodedAccounts>[0], addresses: Array<Address>, config?: FetchAccountsConfig): Promise<MaybeAccount<Transaction>[]>;
