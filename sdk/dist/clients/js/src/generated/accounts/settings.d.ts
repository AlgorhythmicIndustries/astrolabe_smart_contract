/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */
import { fetchEncodedAccount, fetchEncodedAccounts, type Account, type Address, type Codec, type Decoder, type EncodedAccount, type Encoder, type FetchAccountConfig, type FetchAccountsConfig, type MaybeAccount, type MaybeEncodedAccount, type Option, type OptionOrNullable, type ReadonlyUint8Array } from '@solana/kit';
import { type RestrictedSmartAccountSigner, type RestrictedSmartAccountSignerArgs, type SmartAccountSigner, type SmartAccountSignerArgs } from '../types';
export declare const SETTINGS_DISCRIMINATOR: Uint8Array;
export declare function getSettingsDiscriminatorBytes(): ReadonlyUint8Array;
export type Settings = {
    discriminator: ReadonlyUint8Array;
    /**
     * An integer that is used seed the settings PDA. Its incremented by 1
     * inside the program conifg by 1 for each smart account created. This is
     * to ensure uniqueness of each settings PDA without relying on user input.
     *
     * Note: As this represents a DOS vector in the current creation architecture,
     * account creation will be permissioned until compression is implemented.
     */
    seed: bigint;
    /**
     * The authority that can change the smart account settings.
     * This is a very important parameter as this authority can change the signers and threshold.
     *
     * The convention is to set this to `Pubkey::default()`.
     * In this case, the smart account becomes autonomous, so every settings change goes through
     * the normal process of voting by the signers.
     *
     * However, if this parameter is set to any other key, all the setting changes for this smart account settings
     * will need to be signed by the `settings_authority`. We call such a smart account a "controlled smart account".
     */
    settingsAuthority: Address;
    /** Threshold for signatures. */
    threshold: number;
    /** How many seconds must pass between transaction voting settlement and execution. */
    timeLock: number;
    /** Last transaction index. 0 means no transactions have been created. */
    transactionIndex: bigint;
    /**
     * Last stale transaction index. All transactions up until this index are stale.
     * This index is updated when smart account settings (signers/threshold/time_lock) change.
     */
    staleTransactionIndex: bigint;
    /**
     * Field reserved for when archival/compression is implemented.
     * Will be set to Pubkey::default() to mark accounts that should
     * be eligible for archival before the feature is implemented.
     */
    archivalAuthority: Option<Address>;
    /**
     * Field that will prevent a smart account from being archived immediately after unarchival.
     * This is to prevent a DOS vector where the archival authority could
     * constantly unarchive and archive the smart account to prevent it from
     * being used.
     */
    archivableAfter: bigint;
    /** Bump for the smart account PDA seed. */
    bump: number;
    /** Signers attached to the smart account */
    signers: Array<SmartAccountSigner>;
    restrictedSigners: Array<RestrictedSmartAccountSigner>;
    /** Counter for how many sub accounts are in use (improves off-chain indexing) */
    accountUtilization: number;
    reserved1: number;
    reserved2: number;
};
export type SettingsArgs = {
    /**
     * An integer that is used seed the settings PDA. Its incremented by 1
     * inside the program conifg by 1 for each smart account created. This is
     * to ensure uniqueness of each settings PDA without relying on user input.
     *
     * Note: As this represents a DOS vector in the current creation architecture,
     * account creation will be permissioned until compression is implemented.
     */
    seed: number | bigint;
    /**
     * The authority that can change the smart account settings.
     * This is a very important parameter as this authority can change the signers and threshold.
     *
     * The convention is to set this to `Pubkey::default()`.
     * In this case, the smart account becomes autonomous, so every settings change goes through
     * the normal process of voting by the signers.
     *
     * However, if this parameter is set to any other key, all the setting changes for this smart account settings
     * will need to be signed by the `settings_authority`. We call such a smart account a "controlled smart account".
     */
    settingsAuthority: Address;
    /** Threshold for signatures. */
    threshold: number;
    /** How many seconds must pass between transaction voting settlement and execution. */
    timeLock: number;
    /** Last transaction index. 0 means no transactions have been created. */
    transactionIndex: number | bigint;
    /**
     * Last stale transaction index. All transactions up until this index are stale.
     * This index is updated when smart account settings (signers/threshold/time_lock) change.
     */
    staleTransactionIndex: number | bigint;
    /**
     * Field reserved for when archival/compression is implemented.
     * Will be set to Pubkey::default() to mark accounts that should
     * be eligible for archival before the feature is implemented.
     */
    archivalAuthority: OptionOrNullable<Address>;
    /**
     * Field that will prevent a smart account from being archived immediately after unarchival.
     * This is to prevent a DOS vector where the archival authority could
     * constantly unarchive and archive the smart account to prevent it from
     * being used.
     */
    archivableAfter: number | bigint;
    /** Bump for the smart account PDA seed. */
    bump: number;
    /** Signers attached to the smart account */
    signers: Array<SmartAccountSignerArgs>;
    restrictedSigners: Array<RestrictedSmartAccountSignerArgs>;
    /** Counter for how many sub accounts are in use (improves off-chain indexing) */
    accountUtilization: number;
    reserved1: number;
    reserved2: number;
};
export declare function getSettingsEncoder(): Encoder<SettingsArgs>;
export declare function getSettingsDecoder(): Decoder<Settings>;
export declare function getSettingsCodec(): Codec<SettingsArgs, Settings>;
export declare function decodeSettings<TAddress extends string = string>(encodedAccount: EncodedAccount<TAddress>): Account<Settings, TAddress>;
export declare function decodeSettings<TAddress extends string = string>(encodedAccount: MaybeEncodedAccount<TAddress>): MaybeAccount<Settings, TAddress>;
export declare function fetchSettings<TAddress extends string = string>(rpc: Parameters<typeof fetchEncodedAccount>[0], address: Address<TAddress>, config?: FetchAccountConfig): Promise<Account<Settings, TAddress>>;
export declare function fetchMaybeSettings<TAddress extends string = string>(rpc: Parameters<typeof fetchEncodedAccount>[0], address: Address<TAddress>, config?: FetchAccountConfig): Promise<MaybeAccount<Settings, TAddress>>;
export declare function fetchAllSettings(rpc: Parameters<typeof fetchEncodedAccounts>[0], addresses: Array<Address>, config?: FetchAccountsConfig): Promise<Account<Settings>[]>;
export declare function fetchAllMaybeSettings(rpc: Parameters<typeof fetchEncodedAccounts>[0], addresses: Array<Address>, config?: FetchAccountsConfig): Promise<MaybeAccount<Settings>[]>;
