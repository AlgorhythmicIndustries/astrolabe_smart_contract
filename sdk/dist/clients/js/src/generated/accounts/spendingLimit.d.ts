/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */
import { fetchEncodedAccount, fetchEncodedAccounts, type Account, type Address, type Codec, type Decoder, type EncodedAccount, type Encoder, type FetchAccountConfig, type FetchAccountsConfig, type MaybeAccount, type MaybeEncodedAccount, type ReadonlyUint8Array } from '@solana/kit';
import { type Period, type PeriodArgs } from '../types';
export declare const SPENDING_LIMIT_DISCRIMINATOR: Uint8Array<ArrayBuffer>;
export declare function getSpendingLimitDiscriminatorBytes(): ReadonlyUint8Array;
export type SpendingLimit = {
    discriminator: ReadonlyUint8Array;
    /** The settings this belongs to. */
    settings: Address;
    /** Key that is used to seed the SpendingLimit PDA. */
    seed: Address;
    /** The index of the smart account that the spending limit is for. */
    accountIndex: number;
    /**
     * The token mint the spending limit is for.
     * Pubkey::default() means SOL.
     * use NATIVE_MINT for Wrapped SOL.
     */
    mint: Address;
    /**
     * The amount of tokens that can be spent in a period.
     * This amount is in decimals of the mint,
     * so 1 SOL would be `1_000_000_000` and 1 USDC would be `1_000_000`.
     */
    amount: bigint;
    /**
     * The reset period of the spending limit.
     * When it passes, the remaining amount is reset, unless it's `Period::OneTime`.
     */
    period: Period;
    /**
     * The remaining amount of tokens that can be spent in the current period.
     * When reaches 0, the spending limit cannot be used anymore until the period reset.
     */
    remainingAmount: bigint;
    /** Unix timestamp marking the last time the spending limit was reset (or created). */
    lastReset: bigint;
    /** PDA bump. */
    bump: number;
    /** Signers that can use the spending limit. */
    signers: Array<Address>;
    /**
     * The destination addresses the spending limit is allowed to sent funds to.
     * If empty, funds can be sent to any address.
     */
    destinations: Array<Address>;
    /** The expiration timestamp of the spending limit. */
    expiration: bigint;
};
export type SpendingLimitArgs = {
    /** The settings this belongs to. */
    settings: Address;
    /** Key that is used to seed the SpendingLimit PDA. */
    seed: Address;
    /** The index of the smart account that the spending limit is for. */
    accountIndex: number;
    /**
     * The token mint the spending limit is for.
     * Pubkey::default() means SOL.
     * use NATIVE_MINT for Wrapped SOL.
     */
    mint: Address;
    /**
     * The amount of tokens that can be spent in a period.
     * This amount is in decimals of the mint,
     * so 1 SOL would be `1_000_000_000` and 1 USDC would be `1_000_000`.
     */
    amount: number | bigint;
    /**
     * The reset period of the spending limit.
     * When it passes, the remaining amount is reset, unless it's `Period::OneTime`.
     */
    period: PeriodArgs;
    /**
     * The remaining amount of tokens that can be spent in the current period.
     * When reaches 0, the spending limit cannot be used anymore until the period reset.
     */
    remainingAmount: number | bigint;
    /** Unix timestamp marking the last time the spending limit was reset (or created). */
    lastReset: number | bigint;
    /** PDA bump. */
    bump: number;
    /** Signers that can use the spending limit. */
    signers: Array<Address>;
    /**
     * The destination addresses the spending limit is allowed to sent funds to.
     * If empty, funds can be sent to any address.
     */
    destinations: Array<Address>;
    /** The expiration timestamp of the spending limit. */
    expiration: number | bigint;
};
export declare function getSpendingLimitEncoder(): Encoder<SpendingLimitArgs>;
export declare function getSpendingLimitDecoder(): Decoder<SpendingLimit>;
export declare function getSpendingLimitCodec(): Codec<SpendingLimitArgs, SpendingLimit>;
export declare function decodeSpendingLimit<TAddress extends string = string>(encodedAccount: EncodedAccount<TAddress>): Account<SpendingLimit, TAddress>;
export declare function decodeSpendingLimit<TAddress extends string = string>(encodedAccount: MaybeEncodedAccount<TAddress>): MaybeAccount<SpendingLimit, TAddress>;
export declare function fetchSpendingLimit<TAddress extends string = string>(rpc: Parameters<typeof fetchEncodedAccount>[0], address: Address<TAddress>, config?: FetchAccountConfig): Promise<Account<SpendingLimit, TAddress>>;
export declare function fetchMaybeSpendingLimit<TAddress extends string = string>(rpc: Parameters<typeof fetchEncodedAccount>[0], address: Address<TAddress>, config?: FetchAccountConfig): Promise<MaybeAccount<SpendingLimit, TAddress>>;
export declare function fetchAllSpendingLimit(rpc: Parameters<typeof fetchEncodedAccounts>[0], addresses: Array<Address>, config?: FetchAccountsConfig): Promise<Account<SpendingLimit>[]>;
export declare function fetchAllMaybeSpendingLimit(rpc: Parameters<typeof fetchEncodedAccounts>[0], addresses: Array<Address>, config?: FetchAccountsConfig): Promise<MaybeAccount<SpendingLimit>[]>;
