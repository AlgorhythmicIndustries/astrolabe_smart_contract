/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */
import { fetchEncodedAccount, fetchEncodedAccounts, type Account, type Address, type Codec, type Decoder, type EncodedAccount, type Encoder, type FetchAccountConfig, type FetchAccountsConfig, type MaybeAccount, type MaybeEncodedAccount, type ReadonlyUint8Array } from '@solana/kit';
import { type ProposalStatus, type ProposalStatusArgs } from '../types';
export declare const PROPOSAL_DISCRIMINATOR: Uint8Array<ArrayBuffer>;
export declare function getProposalDiscriminatorBytes(): ReadonlyUint8Array;
export type Proposal = {
    discriminator: ReadonlyUint8Array;
    /** The settings this belongs to. */
    settings: Address;
    /** Index of the smart account transaction this proposal is associated with. */
    transactionIndex: bigint;
    /** The rent collector for the proposal account. */
    rentCollector: Address;
    /** The status of the transaction. */
    status: ProposalStatus;
    /** PDA bump. */
    bump: number;
    /** Keys that have approved/signed. */
    approved: Array<Address>;
    /** Keys that have rejected. */
    rejected: Array<Address>;
    /** Keys that have cancelled (Approved only). */
    cancelled: Array<Address>;
};
export type ProposalArgs = {
    /** The settings this belongs to. */
    settings: Address;
    /** Index of the smart account transaction this proposal is associated with. */
    transactionIndex: number | bigint;
    /** The rent collector for the proposal account. */
    rentCollector: Address;
    /** The status of the transaction. */
    status: ProposalStatusArgs;
    /** PDA bump. */
    bump: number;
    /** Keys that have approved/signed. */
    approved: Array<Address>;
    /** Keys that have rejected. */
    rejected: Array<Address>;
    /** Keys that have cancelled (Approved only). */
    cancelled: Array<Address>;
};
export declare function getProposalEncoder(): Encoder<ProposalArgs>;
export declare function getProposalDecoder(): Decoder<Proposal>;
export declare function getProposalCodec(): Codec<ProposalArgs, Proposal>;
export declare function decodeProposal<TAddress extends string = string>(encodedAccount: EncodedAccount<TAddress>): Account<Proposal, TAddress>;
export declare function decodeProposal<TAddress extends string = string>(encodedAccount: MaybeEncodedAccount<TAddress>): MaybeAccount<Proposal, TAddress>;
export declare function fetchProposal<TAddress extends string = string>(rpc: Parameters<typeof fetchEncodedAccount>[0], address: Address<TAddress>, config?: FetchAccountConfig): Promise<Account<Proposal, TAddress>>;
export declare function fetchMaybeProposal<TAddress extends string = string>(rpc: Parameters<typeof fetchEncodedAccount>[0], address: Address<TAddress>, config?: FetchAccountConfig): Promise<MaybeAccount<Proposal, TAddress>>;
export declare function fetchAllProposal(rpc: Parameters<typeof fetchEncodedAccounts>[0], addresses: Array<Address>, config?: FetchAccountsConfig): Promise<Account<Proposal>[]>;
export declare function fetchAllMaybeProposal(rpc: Parameters<typeof fetchEncodedAccounts>[0], addresses: Array<Address>, config?: FetchAccountsConfig): Promise<MaybeAccount<Proposal>[]>;
